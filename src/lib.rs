#![forbid(unsafe_code)]
#![warn(rust_2018_idioms)]

use anyhow::{anyhow, Context as _};
use cargo_metadata as cm;
use duct::cmd;
use indoc::indoc;
use itertools::Itertools as _;
use quote::quote;
use std::{
    collections::{BTreeMap, HashMap, HashSet},
    env, fs,
    ops::Range,
    path::{Path, PathBuf},
};

pub fn gen_doc_rust(crates_dir: Option<&Path>, manifest_path: Option<&Path>) -> anyhow::Result<()> {
    let metadata = &cargo_metadata(manifest_path)?;

    let resolve = metadata.resolve.as_ref().expect("should be present");
    let resolve_root = resolve
        .root
        .as_ref()
        .with_context(|| "this is a virtual manifest")?;

    let extern_crate_names = {
        let explicit_names_in_toml = metadata[resolve_root]
            .dependencies
            .iter()
            .flat_map(|d| &d.rename)
            .collect::<HashSet<_>>();

        let cm::Node { deps, .. } = resolve
            .nodes
            .iter()
            .find(|cm::Node { id, .. }| id == resolve_root)
            .unwrap();

        deps.iter()
            .filter(|cm::NodeDep { dep_kinds, .. }| {
                dep_kinds
                    .iter()
                    .any(|cm::DepKindInfo { kind, .. }| *kind != cm::DependencyKind::Build)
            })
            .flat_map(|cm::NodeDep { name, pkg, .. }| {
                let extern_crate_name = if explicit_names_in_toml.contains(name) {
                    name
                } else {
                    &metadata[pkg].lib_or_proc_macro()?.name
                };
                Some((pkg, extern_crate_name))
            })
            .collect::<HashMap<_, _>>()
    };

    let lib = metadata[resolve_root]
        .lib_or_proc_macro()
        .with_context(|| format!("missing `lib|proc-macro` target in `{}`", resolve_root))?;

    let crates_dir = &crates_dir
        .map(ToOwned::to_owned)
        .unwrap_or_else(|| metadata.workspace_root.join("crates"));

    let library_crates = metadata
        .workspace_members
        .iter()
        .flat_map(|ws_member| {
            let ws_member = &metadata[ws_member];
            let target = ws_member.lib_or_proc_macro()?;
            let src_path = dunce::canonicalize(&target.src_path).ok()?;
            let path1 = ws_member.manifest_path.strip_prefix(crates_dir).ok()?;
            let path2 = src_path.strip_prefix(crates_dir).ok()?;
            let common_path = itertools::zip(path1, path2)
                .filter(|(s1, s2)| s1 == s2)
                .map(|(segment, _)| segment.to_str().expect("this is from a JSON"))
                .collect();
            Some((common_path, ws_member, target))
        })
        .collect::<Vec<(Vec<_>, _, _)>>();

    let mut tree = Tree::default();
    for (path, package, target) in &library_crates {
        tree.insert(path, package, target);
    }

    let generated = &mut indoc! {r"
        // This file is automatically generated by `cargo-online-judge-verification-helper-helper`.
        //! Re-exports the library crates for rustdoc.
        //!
        //! This crate itself is not intended to be used directly.
    "}
    .to_owned();

    tree.expand(&|id| &extern_crate_names[id], generated)?;

    fs::write(&lib.src_path, apply_rustfmt(generated)?)?;
    eprintln!("{:>12} {}", "Wrote", lib.src_path.display());
    return Ok(());

    enum Tree<'cm> {
        Leaf(&'cm cm::PackageId, &'cm cm::Target),
        Joint(BTreeMap<&'cm str, Self>),
    }

    impl<'cm> Tree<'cm> {
        fn insert(
            &mut self,
            path: &[&'cm str],
            package: &'cm cm::Package,
            target: &'cm cm::Target,
        ) {
            match (self, path) {
                (Self::Joint(joint), []) => {
                    joint.insert(&target.name, Self::Leaf(&package.id, target));
                }
                (Self::Joint(joint), [segment, path @ ..]) => {
                    joint
                        .entry(segment)
                        .or_default()
                        .insert(path, package, target);
                }
                _ => panic!(),
            }
        }

        fn expand(
            &self,
            extern_crate_name: &impl Fn(&cm::PackageId) -> &'cm str,
            out: &mut String,
        ) -> anyhow::Result<()> {
            match self {
                Self::Leaf(package_id, target) => {
                    let doc = target.read_crate_level_doc()?;
                    if !doc.is_empty() {
                        *out += "#![doc=";
                        *out += &quote!(#doc).to_string();
                        *out += "]";
                    }
                    *out += "pub use ::";
                    *out += extern_crate_name(package_id);
                    *out += "::*;"
                }
                Self::Joint(joint) => {
                    for (segment, node) in joint {
                        *out += "pub mod ";
                        *out += segment;
                        *out += "{";
                        node.expand(extern_crate_name, out)?;
                        *out += "}";
                    }
                }
            }
            Ok(())
        }
    }

    impl Default for Tree<'_> {
        fn default() -> Self {
            Self::Joint(BTreeMap::new())
        }
    }

    fn apply_rustfmt(code: &str) -> anyhow::Result<String> {
        let rustfmt_exe = PathBuf::from(
            env::var_os("CARGO").with_context(|| "missing `$CARGO` environment variable")?,
        )
        .with_file_name("rustfmt")
        .with_extension(env::consts::EXE_EXTENSION);

        let tempdir = tempfile::Builder::new()
            .prefix("qryxip-competitive-programming-library-xtask-")
            .tempdir()?;

        let path = tempdir.path().join("lib.rs");

        fs::write(&path, code)?;

        cmd!(rustfmt_exe, "--edition", "2018", &path).run()?;

        let code = fs::read_to_string(path)?;

        tempdir.close()?;
        Ok(code)
    }
}

pub fn gen_doc_oj_verify(
    md_dir: Option<&Path>,
    manifest_path: Option<&Path>,
) -> anyhow::Result<()> {
    let metadata = &cargo_metadata(manifest_path)?;

    let library_crates = metadata
        .workspace_members
        .iter()
        .flat_map(|ws_member| {
            let ws_member = &metadata[ws_member];
            let target = ws_member.lib_or_proc_macro()?;
            Some((ws_member, target))
        })
        .collect::<Vec<_>>();

    let md_dir = &md_dir
        .map(ToOwned::to_owned)
        .unwrap_or_else(|| metadata.workspace_root.join("md"));

    fs::create_dir_all(md_dir)
        .with_context(|| format!("could not create `{}`", md_dir.display()))?;

    for (package, target) in library_crates {
        let markdown = format!(
            "---\n\
             title: \"{} (<code>{}</code>)\"\n\
             documentation_of: //{}\n\
             ---\n\
             {}",
            package.name,
            target.name,
            target
                .src_path
                .strip_prefix(&metadata.workspace_root)
                .unwrap_or(&target.src_path)
                .display(),
            modify_doc_for_oj_verify(&target.read_crate_level_doc()?),
        );
        let markdown_path = &md_dir.join(&package.name).with_extension("md");
        fs::write(markdown_path, markdown)
            .with_context(|| format!("could not write `{}`", markdown_path.display()))?;
        eprintln!("{:>12} {}", "Wrote", markdown_path.display());
    }
    return Ok(());

    /// Inserts `rust` in code blocks without language specification.
    fn modify_doc_for_oj_verify(doc: &str) -> String {
        use pulldown_cmark::{CodeBlockKind, Event, Options, Parser, Tag};

        let mut doc = match doc {
            "" => "\n".to_owned(),
            doc => doc
                .lines()
                .map(|s| s.strip_prefix(' ').unwrap_or(s).to_owned() + "\n")
                .join(""),
        };

        #[allow(clippy::redundant_clone)]
        for (_, Range { start, .. }) in Parser::new_ext(&doc.clone(), Options::all())
            .into_offset_iter()
            .filter(|(event, _)| {
                matches!(
                    event,
                    Event::Start(Tag::CodeBlock(CodeBlockKind::Fenced(kind))) if kind.is_empty()
                )
            })
            .collect::<Vec<_>>()
            .into_iter()
            .rev()
        {
            let mut pos = start;
            while doc.as_bytes()[pos] == b'`' {
                pos += 1;
            }
            doc.insert_str(pos, "rust");
        }

        doc
    }
}

fn cargo_metadata(manifest_path: Option<&Path>) -> anyhow::Result<cm::Metadata> {
    let mut cmd = cm::MetadataCommand::new();
    if let Some(manifest_path) = manifest_path {
        cmd.manifest_path(manifest_path);
    }
    cmd.exec().map_err(|err| match err {
        cm::Error::CargoMetadata { stderr } => {
            anyhow!("{}", stderr.trim_start_matches("error: ").trim_end())
        }
        err => anyhow::Error::msg(err),
    })
}

trait PackageExt {
    fn lib_or_proc_macro(&self) -> Option<&cm::Target>;
}

impl PackageExt for cm::Package {
    fn lib_or_proc_macro(&self) -> Option<&cm::Target> {
        self.targets.iter().find(|cm::Target { kind, .. }| {
            [&["lib".to_owned()][..], &["proc-macro".to_owned()]].contains(&&**kind)
        })
    }
}

trait TargetExt {
    fn read_crate_level_doc(&self) -> anyhow::Result<String>;
}

impl TargetExt for cm::Target {
    fn read_crate_level_doc(&self) -> anyhow::Result<String> {
        let syn::File { attrs, .. } = syn::parse_file(&fs::read_to_string(&self.src_path)?)?;

        Ok(attrs
            .iter()
            .flat_map(syn::Attribute::parse_meta)
            .flat_map(|meta| match meta {
                syn::Meta::NameValue(syn::MetaNameValue {
                    path,
                    lit: syn::Lit::Str(lit_str),
                    ..
                }) if path.is_ident("doc") => Some(lit_str.value()),
                _ => None,
            })
            .join("\n"))
    }
}
